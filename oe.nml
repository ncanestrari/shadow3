 fmirr	=             5 - mirror surface: spherical (1), elliptical (2),
 			  toroidal (3), parabolical (4), plane (5),
			  codling slit (6), hyperbolical (7), cone (8),
			  polynomial (9), conic with external coeffs (10).
 f_torus	=             0 - for fmirr=3; mirror pole location:
 				  lower/outer (concave/concave) (0),
				  lower/inner (concave/convex) (1),
				  upper/inner (convex/concave) (2),
				  upper/outer (convex/convex) (3).
 fcyl	=             0 - flag for cylindrical mirror (1), regular mirror
 			  (0).
 f_ext	=             0 - flag for internal/calculated (0) parameters vs.
 			  external/user defined parameters (1).  For
			  fmirr=8, f_ext=1.
 fstat	=             0 - flag to move the source; yes(1), no(0).
 f_screen	=             0 - flag: any screens? yes(1), no (0).
 f_plate	=             0 - flag: if n_plates >= 1; image plates
 				  orthogonal to optical axis. yes(1),
				  no(0).  All plates will have the same
				  orientation.
 fslit	=             0 - flag: slit at continuation plane -- yes(1),
 			  no(0).
 fwrite	=             0 - files to save option: all files (0), mirror file
 			  only -- mirr (1), image file only -- star (2), none
			  (3).
 f_ripple	=             0 - flag: distorted surface - yes(1), no(0).
 f_move	=             0 - flag: move mirror - yes (1), no (0).
 f_thick	=             0 - for multilayers: does the thickness of
 				  the multilayer vary as the cosine of the
				  angle from the pole - yes (1), no (0).
 f_bragg_a	=             0 - flag: is the crystal asymmetric - yes
 				  (1), no (0).
 f_g_s	=             0 - for f_ripple=1 - type of distortion: sinusoidal
 			  (0), gaussian (1), external spline (2).
 f_r_ran	=             0 - empty - read in from gaussian ripple
 				  file in OE generation.
 f_grating	=             0 - flag: is it a grating - yes (1), no (0),
 				  if fzp=1, f_grating=1.
 f_mosaic	=	      1 - if f_crystal=1; flag: mosaic crystal -
 				  yes (1), no (0).
 f_johansson	=	      0 - if f_crystal=1; flag: johansson geometry
 				  - yes (1), no (0).
 f_side	=             0 - for fmirr=4: focus location at image (0) or
 			  source (1).
 f_central	=             1 - flag: autotuning of grating or crystal -
 				  yes (1), no (0).
 f_convex	=             0 - flag: mirror surface concave (0) or
 				  convex (1).
 f_reflec	=             1 - reflectivity of surface: no reflectivity
 				  dependence (0), full polarization
				  dependence (1), no polarization
				  dependence / scalar (2).
 f_rul_abs	=             0 - for f_ruling=5: is the line density
 				  absolute (0) or signed (1) from the
				  origin.
 f_ruling	=             0 - for f_grating=1 - ruling type: constant
 				  on X-Y plane (0), constant on mirror
				  surface (1), holographic (2), fan type
				  (3), reserved (4), polynomial line
				  density (5).
 f_pw	=             2 - for f_ruling=2 - recording source types: both
 			  spherical (0), source plane wave, image
			  spherical (1), source spherical, image plane
			  wave (2), both plane (3).
 f_pw_c	=             0 - for f_ruling=2 - recording sources cylindrical:
 			  none cylindrical (0), source cylindrical, image
			  spherical (1), source spherical, image
			  cylindrical (2), both cylindrical (3).
 f_virtual	=             0 - for f_ruling=2 - source type
 				  real/virtual: entrance slit real, exit
				  slit real (0), entrance slit real, exit
				  slit virtual (1), entrance slit virtual,
				  exit slit real (2), both virtual (3).
 fshape	=             0 - for fhit_c=1: mirror shape rectangular (0), full
 			  ellipse (1), ellipse with hole (2).
 fhit_c	=             0 - flag: mirror dimensions finite: yes (1), no(0).
 f_mono	=             0 - f_grating,f_central=1 - monochromator type: TGM/
 			  Seya (0), ERG (1), Constant Incidence Angle (2),
			  Constant diffraction angle (3), Hunter (4).
 f_refrac	=             0 - flag: reflector (0) or refractor (1).
 f_default	=             0 - flag: focii coincident with continuation
 				  plane - yes (1), no (0).
 f_refl	=             0 - for f_reflec=1,2 - source of optical constants:
			  file generated by PREREFL (0), keyboard (1),
			  multilayers (2).
 f_hunt	=             1 - for f_mono=4: first (1) or second (2) grating.
 f_crystal	=             1 - flag: crystal -- yes (1), no (0).
 f_phot_cent	=             0 - for f_central=1: tune to eV(0) or
 				  Angstroms (1).
 npoint	=             0 - filled in by OE generation.
 ncol	=             0 - filled in by OE generation.
 scr_number	=             0,            0,            0,            0, 
           	              0,            0,            0,            0, 
           	              0,            0
 n_screen	=             0 - for f_screen=1: number of screens.
 i_screen	=             0,            0,            0,            0, 
         	              0,            0,            0,            0, 
         	              0,            0 - for each screen, is it
			      before (1) or after (0) the mirror.
 i_abs	=   0,            0,            0,            0,            0, 
      	    0,            0,            0,            0,            0
	    - for each screen, include absorption yes(1), no (0).
 i_stop	=   0,            0,            0,            0,            0, 
       	    0,            0,            0,            0,            0
	    - for each screen with stop, obstruction (0), or aperture
	    (1).
 i_slit	=   0,            0,            0,            0,            0, 
       	    0,            0,            0,            0,            0
	    - for each screen, is there an aperture stop yes(1), no (0).
 k_slit	=   0,            0,            0,            0,            0, 
       	    0,            0,            0,            0,            0
	    - for each stop/slit, specify a shape: rectangular (0),
	    ellipse (1), external (2).  (external shape **is** implemented, 
            see file format in the header of the routine screen_external_load,
            file shadow_kernel_precpp.F90).
 istar1	=      12345701
 cil_ang	=  0.0000000000000000E+00 - if fcyl=1: angle (degrees) of
 					    cylinder axis from X axis.
 ell_the	=  0.0000000000000000E+00 - for f_ext=1, fmirr=2: CCW
 					    angle between semi-major axis
					    and mirror pole.  
					    for f_ext=1, fmirr=7: angle
					    between major axis and the
					    vector from the hyperbola
					    center to the mirror pole.
 n_plates	=             0 - number of extra image plates
 ig_seed	=             0 - read in from gaussian ripple file in OE
 				  generation.
 mosaic_seed	=	4732094 - random number seed for mosaic crystal
				  calculations.
 alpha	=  0.0000000000000000E+00 - mirror orientation angle (degrees).
 ssour	=  0.0000000000000000E+00 - for f_default=0: distance from object
 				    focus to the mirror pole.
 theta	=  0.0000000000000000E+00 - for f_default=0: incidence angle
 				    (degrees).
 simag	=  0.0000000000000000E+00 - for f_default=0: distance from mirror
 				    pole to image focus.
 rdsour	=  0.0000000000000000E+00 - for fstat=1: source distance from
 				    mirror pole.
 rtheta	=  0.0000000000000000E+00 - for fstat=1: incidence angle
 				    (degrees).
 off_soux	=  0.0000000000000000E+00 - for fstat=1: offset in X in
 					    Mirror Reference Frame (MRF).
 off_souy	=  0.0000000000000000E+00 - for fstat=1: offset in Y in 
					    MRF.
 off_souz	=  0.0000000000000000E+00 - for fstat=1: offset in Z in
 					    MRF.
 alpha_s	=  0.0000000000000000E+00 - for fstat=1: source rotation
 					    around Z (CCW +).
 rlen1	=  0.0000000000000000E+00 - fshape=1: mirror half length +Y.
 				    fshape=3: internal minor axis (Y).
 rlen2	=  0.0000000000000000E+00 - fshape=1: mirror half length -Y.
				    fshape=2,3: external outline minor
				    axis (Y).
 rmirr	=  0.0000000000000000E+00 - f_ext=1, fmirr=1: spherical mirror
 				    radius.
 axmaj	=  0.0000000000000000E+00 - f_ext=1, fmirr=2,7: semi-major axis
 axmin	=  0.0000000000000000E+00 - f_ext=1, fmirr=2,7: semi-minor axis
 cone_a	=  0.0000000000000000E+00 - f_ext=1, fmirr=8: cone half opening
 				    (degrees).
 r_maj	=  0.0000000000000000E+00 - f_ext=1, fmirr=3: tangential (major)
 				    axis.
 r_min	=  0.0000000000000000E+00 - f_ext=1, fmirr=3: sagittal (minor)
 				    axis.
 rwidx1	=  0.0000000000000000E+00 - fshape=1: mirror half width +X.
				    fshape=3: internal major axis (X).
 rwidx2	=  0.0000000000000000E+00 - fshape=1: mirror half width -X.
				    fshape=2,3: external outline major
				    axis (X).
 param	=  0.0000000000000000E+00 - f_ext=1, fmirr=4: parabola parameter P
 				    of Y^2 = 2 P X.
 hunt_h	=  0.0000000000000000E+00 - f_mono=4: monochromator height
 				    (distance between beams.)
 hunt_l	=  0.0000000000000000E+00 - f_mono=4: monochromator length.
 blaze	=  0.0000000000000000E+00 - f_mono=4: blaze length (degrees).
 ruling	=  0.0000000000000000E+00 - f_ruling=0,1: ruling density in l/cm.
				    f_ruling=3: ruling density at center
				    l/cm.
				    f_ruling=5: ruling density at the
				    origin, i.e. a0 of polynomial.
 order	=  0.0000000000000000E+00 - diffraction order, negative inside
 				    (European convention).
 phot_cent	=  11160.00000000000 - for f_phot_cent=1: photon energy
 				       (eV) to autotune grating/crystal to.
 x_rot	=  0.0000000000000000E+00 - f_move=1: rotation about X axis
 				    (degrees, +CW).
 d_spacing	=  0.0000000000000000E+00 - calculated.
 a_bragg	=  0.0000000000000000E+00 - f_bragg_a=1: angle between
 					    crystal planes and surface.
 spread_mos	=  0.400000000000000 - f_mosaic=1: mosaic spread FWHM
 				       (degrees).
 thickness	=  0.100000000000000 - f_mosaic=1: crystal thickness cm.
 r_johansson	=  0.000000000000000E+00 - f_ext=1: johansson radius.
 y_rot	=  0.0000000000000000E+00 - f_move=1: rotation about Y axis
 				    (degrees, +CW).
 z_rot	=  0.0000000000000000E+00 - f_move=1: rotation about Z axis 
				    (degrees, +CW).
 offx	=  0.0000000000000000E+00 - f_move=1: mirror offset in X (MRF).
 offy	=  0.0000000000000000E+00 - f_move=1: mirror offset in Y (MRF).
 offz	=  0.0000000000000000E+00 - f_move=1: mirror offset in Z (MRF).
 sllen	=  0.0000000000000000E+00 - fslit=1: slit length (sagittal, X).
 slwid	=  0.0000000000000000E+00 - fslit=1: slit width (dispersion, Z).
 sltilt	=  0.0000000000000000E+00 - fslit=1: slit tilt (+CCW, degrees).
 cod_len	=  0.0000000000000000E+00 - fmirr=6: codling slit length
 					    (sagittal).
 cod_wid	=  0.0000000000000000E+00 - fmirr=6: codling slit width
 					    (effective, tangential).
 x_sour	=  0.0000000000000000E+00 - fstat=1: source offset in X (source
 				    reference frame -SRF).
 y_sour	=  0.0000000000000000E+00 - fstat=1: source offset in Y (SRF).
 z_sour	=  0.0000000000000000E+00 - fstat=1: source offset in Z (SRF).
 x_sour_rot	=  0.0000000000000000E+00 - fstat=1: source rotation about
 					    X (SRF).
 y_sour_rot	=  0.0000000000000000E+00 - fstat=1: source rotation about
					    Y (SRF).
 z_sour_rot	=  0.0000000000000000E+00 - fstat=1: source rotation about
					    Z (SRF).
 r_lambda	=  0.0000000000000000E+00 - f_phot_cent=1: Angstroms to
 					    autotune grating/crystal to.
 theta_i	=  0.0000000000000000E+00 - f_plate=1: elevation (degrees)
					    Y=0 plane rotated about the X
					    axis, +CCW.
 alpha_i	=  0.0000000000000000E+00 - f_plate=1: azimuth (degrees)
					    Y=0 plane rotated about the Z
					    axis, +CCW.
 t_incidence	=  10.00000000000000 - incidence angle (degrees), defining
 				       optical axis.
 t_source	=  5000.000000000000 - source plane distance
 t_image	=  150.0000000000000 - image plane distance
 t_reflection	=  10.00000000000000 - reflection angle (degrees).
 file_source	=  
            	   'BEGIN.DAT        - for first OE, filename of SOURCE
		   '		       array.  if unchanged, BEGIN.DAT.
 file_rip	=  
         	   'NONE SPECIFIED   - for f_ripple=1, f_g_s=2,3: file
		   '		       containing the distortion information.
 file_refl	=  
          	   'GAAS.SHA         - for f_crystal=1: file containing
		   '		       the crystal parameters.
				       for f_reflec=1,2 and f_refl=0: file
				       with optical constants.
				       for f_reflec=1,2 and f_refl=2: file
				       with thicknesses and refractive
				       indices for multilayers.
 file_abs	=  
         	   'NONE SPECIFIED   - for each screen with absorption,
		   ',		       file containing optical constants. 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  '
 file_mir	=  
         	   'NONE SPECIFIED   - for fmirr=9(polynomial): file
		   '		       containing the polynomial description.
 thick	=  0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00
		- for each screen including absorption, thickness of the
		film in cm.
 rx_slit	=  0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00
		- for each slit/stop in a screen, dimension in X.
 rz_slit	=  0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00
		- for each slit/stop in a screen, dimension in Z.
 sl_dis	=  0.0000000000000000E+00, 0.0000000000000000E+00, 
       	   0.0000000000000000E+00, 0.0000000000000000E+00, 
       	   0.0000000000000000E+00, 0.0000000000000000E+00, 
       	   0.0000000000000000E+00, 0.0000000000000000E+00, 
       	   0.0000000000000000E+00, 0.0000000000000000E+00
		- for each screen, absolute distance from the mirror.
 file_scr_ext	=  
         	   'NONE SPECIFIED   - for each screen with external polygon
		   ',		       (k_slit=2) file containing the polygon
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  ', 
         	   'NONE SPECIFIED                                                                  '
 d_plate	=  0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00, 0.0000000000000000E+00, 
        	   0.0000000000000000E+00
		- for n_plates>=1: for each plate, the distance from the
		mirror center to the plate.
 ccc	=  0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00, 
      	   0.0000000000000000E+00, 0.0000000000000000E+00
		- for fmirr=10, the coeffs OE surface in form of conic equation:
                  ccc[1]*X^2 + ccc[2]*Y^2 + ccc[3]*Z^2 + 
                  ccc[4]*X*Y + ccc[5]*Y*Z + ccc[6]*X*Z  + 
                  ccc[7]*X + ccc[8]*Y + ccc[9]*Z + ccc[10] = 0  
 fzp	=             0 - flag: Fresnel Zone Plate -- yes(1), no(0).  set
 			  f_grating=1.
 holo_r1	=  0.0000000000000000E+00 - f_ruling=2: defining the
 					    creation of the hologram:
					    entrance slit distance (cm).
 holo_r2	=  0.0000000000000000E+00 - f_ruling=2: exit slit distance
 					    (cm).
 holo_del	=  0.0000000000000000E+00 - f_ruling=2: entrance slit
 					    incidence angle (degrees).
 holo_gam	=  0.0000000000000000E+00 - f_ruling=2: exit slit
 					    incidence angle (degrees).
 holo_w	=  0.0000000000000000E+00 - f_ruling=2: recording wavelength
 				    (angstoms).
 holo_rt1	=  0.0000000000000000E+00 - f_ruling=2: entrance slit
 					    rotation angle (degrees).
 holo_rt2	=  0.0000000000000000E+00 - f_ruling=2: exit slit rotation
 					    angle (degrees).
 azim_fan	=  0.0000000000000000E+00 - f_ruling=3: position of
 					    ruling focus on mirror plane.
					    angle from Y, degrees, +CCW.
 dist_fan	=  0.0000000000000000E+00 - f_ruling=3: distance from
 					    grating center (cm).
 coma_fac	=  0.0000000000000000E+00 - f_ruling=3: coma correction
 					    factor, 0 if none.
 alfa	=  0.0000000000000000E+00 - f_refl=1: alpha of the complex
 				    dielectric constant defined by: 
				    epsilon = (1-alpha)+i gamma
 gamma	=  0.0000000000000000E+00 - f_refl=1: gamma of the above
 				    equation.

 f_r_ind =             0 - for f_refrac=1 - source of optical constants, from 
                          keyboard (constant value) or PREREFL preprocessor (file):
                          (0) keyboard in both object and image spaces 
                          (1) file in object space, keyboard in image space
                          (2) keyboard in object space, file in image space
                          (3) file in both object and image space
 r_ind_obj	=  1.000000000000000 - f_refrac=1,f_r_ind=0,2: index of refraction in
 				       object space.
 r_ind_ima	=  1.000000000000000 - f_refrac=1,f_r_ind=0,1: index of refraction in
 				       image space.
 r_attenuation_obj	=  0.0       - f_refrac=1,f_r_ind=0,2: attenuation coefficient in 
 				       object space. Units of UserUnitLength^(-1)
 r_attenuation_ima	=  0.0       - f_refrac=1,f_r_ind=0,1: attenuation coefficient in 
 				       image space. Units of UserUnitLength^(-1)
 rile_r_ind_obj	=  
         	   'NONE SPECIFIED   - for f_refrac=1,f_r_ind=1,3 file generated by PREREFL
 rile_r_ind_ima	=  
         	   'NONE SPECIFIED   - for f_refrac=1,f_r_ind=2,3 file generated by PREREFL
 rul_a1	=  0.0000000000000000E+00 - f_ruling=5: a1 coefficient of
 				    polynomial.
 rul_a2	=  0.0000000000000000E+00 - f_ruling=5: a2 coefficient of
 				    polynomial.
 rul_a3	=  0.0000000000000000E+00 - f_ruling=5: a3 coefficient of
				    polynomial.
 rul_a4	=  0.0000000000000000E+00 - f_ruling=5: a4 coefficient of
				    polynomial.
 x_rip_amp	=  0.0000000000000000E+00 - f_g_s=0: amplitude of
 					    distortion along X axis.
 x_rip_wav	=  0.0000000000000000E+00 - f_g_s=0: wavelength along X
 					    axis.
 x_phase	=  0.0000000000000000E+00 - f_g_s=0: phase for X axis; 0
 					    implies maximum at origin.
 y_rip_amp	=  0.0000000000000000E+00 - f_g_s=0: amplitutde along Y
 					    axis.
 y_rip_wav	=  0.0000000000000000E+00 - f_g_s=0: wavelength along Y.
 y_phase	=  0.0000000000000000E+00 - f_g_s=0: phase for Y axis.
 n_rip	=             0 - read in from gaussian ripple file in OE
 			  generation.
 oe_number	=             0 - the rest of the variables are filled
 idummy	=             0           in during OE generation.
 dummy	=  0.0000000000000000E+00
